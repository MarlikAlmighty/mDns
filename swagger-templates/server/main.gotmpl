package main

{{ $name := .Name }}
{{ $operations := .Operations }}

import (

{{range $index, $op := .Operations}}
        {{ $found := false }}
        {{ range $i, $sop := $operations }}
            {{ if and (gt $i $index ) (eq $op.Package $sop.Package)}}
                {{ $found = true }}
            {{end}}
        {{end}}
        {{ if not $found }}
        api{{ pascalize $op.Package }} "{{$op.GenCommon.TargetImportPath}}/{{ $op.RootPackage }}/operations/{{ $op.Package }}"
        {{end}}
    {{end}}

	"os"
	"log"
    "strconv"
    "github.com/go-openapi/loads"
)

func main() {

	// to catch panic
    	defer func() {
    		if r := recover(); r != nil {
    			log.Println("Recovered func, we got panic:", r)
    		}
    	}()

    	// get the configuration for the application through ENV
    	c := config.New()
    	if err := c.GetEnv(); err != nil {
    		log.Fatal("get environment keys: ", err)
    	}

    	var w *dump.Wrapper

    	// check if we have a data dump
    	if _, err := os.Stat(c.FileToDump); err != nil {
    		if os.IsNotExist(err) {
    			if w, err = dump.New(&c.FileToDump); err != nil {
    				log.Fatal(err)
    			}
    			defer w.DB.Close()
    		}
    	}

    	// starting the application core
    	core := app.New(c, w)

    	// generating host certificates
    	if err := core.GenerateCerts(); err != nil {
    		log.Fatal("generating certs: ", err)
    	}

    	// convert ipv4 to ipv6 and save to model
    	if c.IPV6 == "" {
    		ipv6, err := core.IPV4ToIPV6(c.IPV4)
    		if err != nil {
    			log.Fatal("convert ipv4 to ipv6: ", err)
    		}
    		c.IPV6 = ipv6
    	}

    	// get certificates from files and save them to the model
    	if crt, key, err := core.CertsFromFile(); err != nil {
    		log.Fatal("get certs from file: ", err)
    	} else {
    		c.PublicKey = crt
    		c.PrivateKey = key
    	}

    	// TODO Change me
    	_ = data.NewResolvedData(c)

    	// wrapper over dns lib
    	r := wrapper.New()
    	if err := r.Run(); err != nil {
    		log.Fatal("run dns service: ", err)
    	}
    	defer r.ShutDown()

    	var (
    		swaggerSpec *loads.Document
    		err         error
    	)
	if swaggerSpec, err = loads.Analyzed(restapi.SwaggerJSON, ""); err != nil {
		log.Fatal("loads swagger spec", err)
	}

    api := operations.New{{ pascalize .Name }}API(swaggerSpec)

	{{range .Operations}}
        api.{{ pascalize .Package }}{{ pascalize .Name }}Handler = api{{ pascalize .Package }}.{{ pascalize .Name }}HandlerFunc(core.{{ pascalize .Name }}Handler)
        {{- end}}

    server := {{ .APIPackage }}.NewServer(api)

	server.ConfigureAPI()

	var port int
	if port, err = strconv.Atoi(c.HTTPPort); err != nil {
		log.Fatal("can't convert port from string", err)
	}

	server.Port = port

	if err := server.Serve(); err != nil {
		log.Fatal("start server", err)
	}
}